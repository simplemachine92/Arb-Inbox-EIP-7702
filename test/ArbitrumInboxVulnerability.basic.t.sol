// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "forge-std/console.sol";
import "./EIP7702Utils.sol";

/**
 * @title ArbitrumInboxVulnerabilityBasicTest
 * @notice Basic test suite to verify account setup without requiring mainnet fork
 * @dev This test verifies that our account setup works correctly before testing against real contract
 */
contract ArbitrumInboxVulnerabilityBasicTest is Test, EIP7702Utils {
    
    /// @notice Test accounts for different account types
    address public regularEOA;
    address public regularContract;
    address public eip7702Account;
    address public delegateContract;
    
    /// @notice Mock contract for testing regular contract behavior
    MockContract public mockContract;
    
    /**
     * @notice Set up test environment with test accounts (no fork needed)
     */
    function setUp() public {
        // Set up test accounts
        setupTestAccounts();
        
        console.log("=== Basic Account Setup Test ===");
        console.log("Regular EOA:", regularEOA);
        console.log("Regular Contract:", address(mockContract));
        console.log("EIP-7702 Account:", eip7702Account);
        console.log("Delegate Contract:", delegateContract);
    }
    
    /**
     * @notice Creates and configures test accounts for different scenarios
     */
    function setupTestAccounts() internal {
        // Create regular EOA
        regularEOA = makeAddr("regularEOA");
        vm.deal(regularEOA, 10 ether);
        
        // Deploy a regular contract
        mockContract = new MockContract();
        regularContract = address(mockContract);
        vm.deal(regularContract, 10 ether);
        
        // Create delegate contract for EIP-7702
        delegateContract = address(new MockDelegateContract());
        
        // Create EIP-7702 account
        eip7702Account = createEIP7702Account("eip7702User", delegateContract);
        vm.deal(eip7702Account, 10 ether);
    }
    
    /**
     * @notice Test that all account types are set up correctly
     */
    function test_AccountSetup() public view {
        // Verify regular EOA
        assertEq(getAccountType(regularEOA), 0, "Regular EOA should have account type 0");
        assertEq(getCodeSize(regularEOA), 0, "Regular EOA should have no code");
        
        // Verify regular contract
        assertEq(getAccountType(regularContract), 2, "Regular contract should have account type 2");
        assertTrue(getCodeSize(regularContract) > 0, "Regular contract should have code");
        
        // Verify EIP-7702 account
        assertEq(getAccountType(eip7702Account), 1, "EIP-7702 account should have account type 1");
        assertEq(getCodeSize(eip7702Account), 23, "EIP-7702 account should have 23 bytes of code");
        assertTrue(verifyEIP7702Account(eip7702Account), "EIP-7702 account should be valid");
        
        // Verify all accounts have ETH
        assertTrue(regularEOA.balance >= 1 ether, "Regular EOA should have ETH");
        assertTrue(regularContract.balance >= 1 ether, "Regular contract should have ETH");
        assertTrue(eip7702Account.balance >= 1 ether, "EIP-7702 account should have ETH");
    }
    
    /**
     * @notice Test the vulnerability detection logic
     */
    function test_VulnerabilityDetection() public view {
        console.log("\n=== Vulnerability Detection Test ===");
        
        // Test how each account type appears to basic extcodesize checks
        bool eoaHasCode = hasCode(regularEOA);
        bool contractHasCode = hasCode(regularContract);
        bool eip7702HasCode = hasCode(eip7702Account);
        
        console.log("Regular EOA has code:", eoaHasCode);
        console.log("Regular Contract has code:", contractHasCode);
        console.log("EIP-7702 Account has code:", eip7702HasCode);
        
        // Verify the vulnerability: EIP-7702 appears to have code
        assertFalse(eoaHasCode, "EOA should not have code");
        assertTrue(contractHasCode, "Contract should have code");
        assertTrue(eip7702HasCode, "EIP-7702 account appears to have code (vulnerability!)");
        
        // Show address aliasing results
        address eoaL2 = eoaHasCode ? applyL1ToL2Alias(regularEOA) : regularEOA;
        address contractL2 = contractHasCode ? applyL1ToL2Alias(regularContract) : regularContract;
        address eip7702L2 = eip7702HasCode ? applyL1ToL2Alias(eip7702Account) : eip7702Account;
        
        console.log("\nL2 Address Results:");
        console.log("EOA L1->L2:", regularEOA, "->", eoaL2);
        console.log("Contract L1->L2:", regularContract, "->", contractL2);
        console.log("EIP-7702 L1->L2:", eip7702Account, "->", eip7702L2);
        
        // Verify correct behavior
        assertEq(eoaL2, regularEOA, "EOA should not be aliased");
        assertNotEq(contractL2, regularContract, "Contract should be aliased");
        assertNotEq(eip7702L2, eip7702Account, "EIP-7702 gets incorrectly aliased (VULNERABILITY!)");
    }
    
    /**
     * @notice Apply L1 to L2 address aliasing (Arbitrum's formula)
     */
    function applyL1ToL2Alias(address l1Address) public pure returns (address) {
        uint160 offset = uint160(0x1111000000000000000000000000000000001111);
        unchecked {
            return address(uint160(l1Address) + offset);
        }
    }
}

/**
 * @notice Mock contract for testing regular contract behavior
 */
contract MockContract {
    uint256 public value;
    
    function setValue(uint256 _value) external {
        value = _value;
    }
    
    function getValue() external view returns (uint256) {
        return value;
    }
}

/**
 * @notice Mock delegate contract for EIP-7702 testing
 */
contract MockDelegateContract {
    uint256 public delegatedValue;
    
    function setDelegatedValue(uint256 _value) external {
        delegatedValue = _value;
    }
    
    function getDelegatedValue() external view returns (uint256) {
        return delegatedValue;
    }
}