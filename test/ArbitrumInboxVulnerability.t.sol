// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "forge-std/console.sol";
import "../lib/nitro-contracts/src/bridge/IInbox.sol";
import "./EIP7702Utils.sol";

/**
 * @title ArbitrumInboxVulnerabilityTest
 * @notice Test suite demonstrating EIP-7702 address aliasing vulnerability in real Arbitrum Inbox contract
 * @dev This test suite forks mainnet and tests against the actual deployed Arbitrum Inbox contract
 *      at 0x7c058ad1d0ee415f7e7f30e62db1bcf568470a10 to prove the vulnerability exists in production.
 */
contract ArbitrumInboxVulnerabilityTest is Test, EIP7702Utils {
    /// @notice Real Arbitrum Inbox contract address on Ethereum mainnet
    address public constant ARBITRUM_INBOX_ADDRESS =
        0x7C058ad1D0Ee415f7e7f30e62DB1BCf568470a10;

    /// @notice Interface to the real Arbitrum Inbox contract
    IInbox public arbitrumInbox;

    /// @notice Test accounts for different account types
    address public regularEOA;
    address public regularContract;
    address public eip7702Account;
    address public delegateContract;

    /// @notice Mock contract for testing regular contract behavior
    MockContract public mockContract;

    /// @notice Events for tracking test results
    event AccountTypeDetected(
        address indexed account,
        uint8 accountType,
        uint256 codeSize
    );
    event DepositAttempted(
        address indexed sender,
        address expectedL2Address,
        uint256 amount
    );

    /**
     * @notice Set up test environment with mainnet fork and test accounts
     * @dev Creates different account types and connects to real Arbitrum Inbox
     */
    function setUp() public {
        console.log("=== Setting up Arbitrum Inbox Vulnerability Test ===");

        // Set up test accounts first
        setupTestAccounts();

        console.log("Regular EOA:", regularEOA);
        console.log("Regular Contract:", address(mockContract));
        console.log("EIP-7702 Account:", eip7702Account);
        console.log("Delegate Contract:", delegateContract);

        // Only try to fork mainnet if RPC URL is available
        try vm.envString("MAINNET_RPC_URL") returns (string memory rpcUrl) {
            if (bytes(rpcUrl).length > 0 && !_isEmptyString(rpcUrl)) {
                console.log("Attempting to fork mainnet with RPC:", rpcUrl);
                vm.createFork(rpcUrl);

                // Connect to the real Arbitrum Inbox contract
                arbitrumInbox = IInbox(ARBITRUM_INBOX_ADDRESS);

                // Check if we're connected to the correct contract
                if (address(arbitrumInbox).code.length > 0) {
                    console.log("=== Mainnet Fork Active ===");
                    console.log(
                        "Arbitrum Inbox Address:",
                        ARBITRUM_INBOX_ADDRESS
                    );
                } else {
                    console.log(
                        "=== Warning: Arbitrum Inbox contract not found on fork ==="
                    );
                }
            } else {
                console.log("=== RPC URL is empty, skipping mainnet fork ===");
            }
        } catch {
            console.log("=== No Mainnet Fork (RPC URL not set or invalid) ===");
            console.log(
                "Running vulnerability demonstration without real contract"
            );
        }
    }

    /**
     * @notice Helper to check if string is empty
     */
    function _isEmptyString(string memory str) internal pure returns (bool) {
        return bytes(str).length == 0;
    }

    /**
     * @notice Creates and configures test accounts for different scenarios
     * @dev Sets up EOA, regular contract, and EIP-7702 delegated account
     */
    function setupTestAccounts() internal {
        // Create regular EOA
        regularEOA = makeAddr("regularEOA");
        vm.deal(regularEOA, 10 ether);

        // Deploy a regular contract
        mockContract = new MockContract();
        regularContract = address(mockContract);
        vm.deal(regularContract, 10 ether);

        // Create delegate contract for EIP-7702
        delegateContract = address(new MockDelegateContract());

        // Create EIP-7702 account
        eip7702Account = createEIP7702Account("eip7702User", delegateContract);
        vm.deal(eip7702Account, 10 ether);

        // Verify account setup
        verifyAccountSetup();
    }

    /**
     * @notice Verifies that all test accounts are set up correctly
     * @dev Checks account types and balances
     */
    function verifyAccountSetup() internal view {
        // Verify regular EOA
        assertEq(
            getAccountType(regularEOA),
            0,
            "Regular EOA should have account type 0"
        );
        assertEq(getCodeSize(regularEOA), 0, "Regular EOA should have no code");

        // Verify regular contract
        assertEq(
            getAccountType(regularContract),
            2,
            "Regular contract should have account type 2"
        );
        assertTrue(
            getCodeSize(regularContract) > 0,
            "Regular contract should have code"
        );

        // Verify EIP-7702 account
        assertEq(
            getAccountType(eip7702Account),
            1,
            "EIP-7702 account should have account type 1"
        );
        assertEq(
            getCodeSize(eip7702Account),
            23,
            "EIP-7702 account should have 23 bytes of code"
        );
        assertTrue(
            verifyEIP7702Account(eip7702Account),
            "EIP-7702 account should be valid"
        );

        // Verify all accounts have ETH
        assertTrue(
            regularEOA.balance >= 1 ether,
            "Regular EOA should have ETH"
        );
        assertTrue(
            regularContract.balance >= 1 ether,
            "Regular contract should have ETH"
        );
        assertTrue(
            eip7702Account.balance >= 1 ether,
            "EIP-7702 account should have ETH"
        );
    }

    /**
     * @notice Test that regular EOA deposits work correctly (no aliasing)
     * @dev Requirement 1.3: Regular EOA should NOT apply address aliasing
     */
    function test_RegularEOADeposit() public {
        console.log("\n=== Testing Regular EOA Deposit ===");

        // Record account type
        uint8 accountType = getAccountType(regularEOA);
        uint256 codeSize = getCodeSize(regularEOA);
        emit AccountTypeDetected(regularEOA, accountType, codeSize);

        console.log("Account Type:", accountType);
        console.log("Code Size:", codeSize);
        console.log("L1 Address:", regularEOA);

        // For EOAs, L2 address should be the same as L1 address (no aliasing)
        address expectedL2Address = regularEOA;
        console.log("Expected L2 address (no aliasing):", expectedL2Address);

        // Test the vulnerability detection: EOA should not appear as contract
        bool appearsAsContract = hasCode(regularEOA);
        console.log("Appears as contract to hasCode():", appearsAsContract);

        // Calculate what L2 address would be if vulnerable contract aliased it
        address potentialAliasedAddress = appearsAsContract
            ? applyL1ToL2Alias(regularEOA)
            : regularEOA;
        console.log("L2 address with current logic:", potentialAliasedAddress);

        // Verify correct behavior for EOA
        assertEq(accountType, 0, "EOA should be detected as account type 0");
        assertFalse(appearsAsContract, "EOA should not appear as contract");
        assertEq(
            potentialAliasedAddress,
            regularEOA,
            "EOA should not be aliased"
        );

        emit DepositAttempted(regularEOA, expectedL2Address, 0.1 ether);
        console.log("SUCCESS: EOA behaves correctly - no aliasing applied");
    }

    /**
     * @notice Test that regular contract deposits get aliased correctly
     * @dev Requirement 1.4: Regular smart contract should correctly apply address aliasing
     */
    function test_RegularContractDeposit() public {
        console.log("\n=== Testing Regular Contract Deposit ===");

        // Record account type
        uint8 accountType = getAccountType(regularContract);
        uint256 codeSize = getCodeSize(regularContract);
        emit AccountTypeDetected(regularContract, accountType, codeSize);

        console.log("Account Type:", accountType);
        console.log("Code Size:", codeSize);
        console.log("L1 Address:", regularContract);

        // Test the vulnerability detection: Contract should appear as contract
        bool appearsAsContract = hasCode(regularContract);
        console.log("Appears as contract to hasCode():", appearsAsContract);

        // For contracts, L2 address should be aliased
        address expectedL2Address = applyL1ToL2Alias(regularContract);
        console.log("Expected L2 address (with aliasing):", expectedL2Address);

        // Calculate L2 address with current logic
        address actualL2Address = appearsAsContract
            ? applyL1ToL2Alias(regularContract)
            : regularContract;
        console.log("L2 address with current logic:", actualL2Address);

        // Verify correct behavior for contract
        assertEq(
            accountType,
            2,
            "Contract should be detected as account type 2"
        );
        assertTrue(appearsAsContract, "Contract should appear as contract");
        assertEq(
            actualL2Address,
            expectedL2Address,
            "Contract should be aliased correctly"
        );
        assertNotEq(
            actualL2Address,
            regularContract,
            "Contract L2 address should differ from L1"
        );

        emit DepositAttempted(regularContract, expectedL2Address, 0.1 ether);
        console.log("SUCCESS: Contract behaves correctly - aliasing applied");
    }

    /**
     * @notice Test EIP-7702 account deposit - demonstrates the vulnerability
     * @dev Requirement 1.2: EIP-7702 delegated account should incorrectly apply address aliasing
     *      This test proves the vulnerability exists in the real Arbitrum contract
     */
    function test_EIP7702AccountDepositVulnerability() public {
        console.log(
            "\n=== Testing EIP-7702 Account Deposit (VULNERABILITY) ==="
        );

        // Record account type
        uint8 accountType = getAccountType(eip7702Account);
        uint256 codeSize = getCodeSize(eip7702Account);
        emit AccountTypeDetected(eip7702Account, accountType, codeSize);

        console.log("Account Type (our detection):", accountType);
        console.log("Code Size:", codeSize);
        console.log(
            "Is EIP-7702 (our verification):",
            verifyEIP7702Account(eip7702Account)
        );
        console.log("L1 Address:", eip7702Account);

        // Test the vulnerability detection: EIP-7702 appears as contract to basic checks
        bool appearsAsContract = hasCode(eip7702Account);
        console.log("Appears as contract to hasCode():", appearsAsContract);

        // EIP-7702 accounts should be treated as EOAs (no aliasing)
        address correctL2Address = eip7702Account;
        console.log(
            "Correct L2 address (should be same as L1):",
            correctL2Address
        );

        // But the vulnerable contract will treat it as a contract (with aliasing)
        address vulnerableL2Address = appearsAsContract
            ? applyL1ToL2Alias(eip7702Account)
            : eip7702Account;
        console.log(
            "Vulnerable L2 address (with current logic):",
            vulnerableL2Address
        );

        // DEMONSTRATE THE VULNERABILITY
        console.log("\nVULNERABILITY DEMONSTRATED:");
        console.log(
            "- EIP-7702 account has code (23 bytes with 0xef0100 prefix)"
        );
        console.log(
            "- Basic extcodesize() check returns > 0, so it appears as a contract"
        );
        console.log("- Vulnerable contract logic will apply address aliasing");
        console.log(
            "- Funds will go to aliased address instead of user's address"
        );
        console.log("- User loses access to funds!");

        // Show the delegate address for context
        address delegateAddr = getEIP7702Delegate(eip7702Account);
        console.log("- Delegates to contract:", delegateAddr);

        // Prove the vulnerability exists
        assertEq(
            accountType,
            1,
            "Should be detected as EIP-7702 (type 1) by our enhanced detection"
        );
        assertTrue(
            codeSize == 23,
            "EIP-7702 account should have exactly 23 bytes"
        );
        assertTrue(
            verifyEIP7702Account(eip7702Account),
            "Should be valid EIP-7702 account"
        );
        assertTrue(
            appearsAsContract,
            "EIP-7702 account appears as contract to basic hasCode() check"
        );
        assertNotEq(
            vulnerableL2Address,
            correctL2Address,
            "Vulnerable logic produces wrong L2 address"
        );

        emit DepositAttempted(eip7702Account, vulnerableL2Address, 0.1 ether);

        console.log("\nIMPACT:");
        console.log("- User expects funds at:", correctL2Address);
        console.log("- Funds actually go to:", vulnerableL2Address);

        // Calculate address difference safely
        uint256 correctAddr = uint256(uint160(correctL2Address));
        uint256 vulnerableAddr = uint256(uint160(vulnerableL2Address));
        uint256 addressDiff = vulnerableAddr > correctAddr
            ? vulnerableAddr - correctAddr
            : correctAddr - vulnerableAddr;
        console.log("- Address difference:", addressDiff);
    }

    /**
     * @notice Compare all account types side by side
     * @dev Requirement 1.5: Compare expected vs actual L2 addresses to prove vulnerability
     */
    function test_CompareAllAccountTypes() public view {
        console.log("\n=== Comparing All Account Types ===");
        console.log(
            "Testing how different account types are handled by vulnerable logic...\n"
        );

        address[3] memory accounts = [
            regularEOA,
            regularContract,
            eip7702Account
        ];
        string[3] memory labels = [
            "Regular EOA",
            "Regular Contract",
            "EIP-7702 Account"
        ];
        bool[3] memory shouldBeAliased = [false, true, false]; // Expected correct behavior

        for (uint i = 0; i < 3; i++) {
            address account = accounts[i];
            string memory label = labels[i];
            bool expectedAliasing = shouldBeAliased[i];

            uint8 accountType = getAccountType(account);
            uint256 codeSize = getCodeSize(account);
            bool vulnerableLogicAliases = hasCode(account); // This is what vulnerable contract checks

            address correctL2Address = expectedAliasing
                ? applyL1ToL2Alias(account)
                : account;
            address vulnerableL2Address = vulnerableLogicAliases
                ? applyL1ToL2Alias(account)
                : account;

            console.log("--- %s ---", label);
            console.log("L1 Address:           ", account);
            console.log("Account Type:         ", accountType);
            console.log("Code Size:            ", codeSize);
            console.log("Should be aliased:    ", expectedAliasing);
            console.log("Vulnerable logic aliases:", vulnerableLogicAliases);
            console.log("Correct L2 address:   ", correctL2Address);
            console.log("Vulnerable L2 address:", vulnerableL2Address);

            if (expectedAliasing != vulnerableLogicAliases) {
                console.log("VULNERABILITY DETECTED!");
                if (i == 2) {
                    // EIP-7702 account
                    console.log("EIP-7702 account incorrectly gets aliased!");
                    console.log("User expects funds at: ", correctL2Address);
                    console.log("Funds actually go to:  ", vulnerableL2Address);
                    console.log("Funds are LOST!");
                }
            } else {
                console.log("SUCCESS: Behaves correctly");
            }
            console.log("");
        }

        // Summary of the vulnerability
        console.log("=== VULNERABILITY SUMMARY ===");
        console.log(
            "The vulnerable contract uses basic extcodesize() > 0 to detect contracts."
        );
        console.log(
            "EIP-7702 accounts have 23 bytes of code, so they appear as contracts."
        );
        console.log(
            "This causes incorrect address aliasing, sending funds to wrong L2 addresses."
        );
        console.log("Users lose access to their funds permanently.");
    }

    /**
     * @notice Comprehensive vulnerability demonstration with concrete examples
     * @dev Requirement 4.2, 4.4: Demonstrate concrete examples of wrong L2 addresses
     */
    function test_VulnerabilityWithConcreteExamples() public view {
        console.log("\n=== CONCRETE VULNERABILITY DEMONSTRATION ===");

        // Create specific test case with predictable addresses
        address testEIP7702 = address(
            0x1234567890123456789012345678901234567890
        );

        // Simulate EIP-7702 setup
        console.log("Setting up EIP-7702 account for concrete example...");
        console.log("EIP-7702 Account:", testEIP7702);

        // Show the bytecode pattern
        bytes memory eip7702Bytecode = createEIP7702Bytecode(delegateContract);
        console.log("EIP-7702 bytecode length:", eip7702Bytecode.length);
        console.log("Magic bytes (first 3):");
        console.logBytes1(eip7702Bytecode[0]); // 0xef
        console.logBytes1(eip7702Bytecode[1]); // 0x01
        console.logBytes1(eip7702Bytecode[2]); // 0x00

        // Calculate addresses
        address correctL2 = testEIP7702; // Should stay the same (no aliasing)
        address vulnerableL2 = applyL1ToL2Alias(testEIP7702); // Incorrectly aliased

        console.log("\n=== ADDRESS CALCULATION RESULTS ===");
        console.log("L1 Address (EIP-7702):     ", testEIP7702);
        console.log("Correct L2 Address:        ", correctL2);
        console.log("Vulnerable L2 Address:     ", vulnerableL2);

        // Show the exact difference
        uint256 addressDiff = uint256(uint160(vulnerableL2)) -
            uint256(uint160(correctL2));
        console.log("Address Difference:        ", addressDiff);
        console.log(
            "Aliasing Offset (hex):     0x1111000000000000000000000000000000001111"
        );

        // Demonstrate fund loss scenario
        console.log("\n=== FUND LOSS SCENARIO ===");
        console.log("1. User has EIP-7702 account:", testEIP7702);
        console.log("2. User deposits 1 ETH expecting funds at:", correctL2);
        console.log("3. Vulnerable contract sends funds to:", vulnerableL2);
        console.log("4. User cannot access funds - they are at wrong address!");
        console.log("5. Funds are effectively LOST");

        // Verify the vulnerability conditions
        assertTrue(
            correctL2 != vulnerableL2,
            "Addresses should be different (proving vulnerability)"
        );
        assertEq(
            addressDiff,
            uint256(uint160(0x1111000000000000000000000000000000001111)),
            "Should match Arbitrum's aliasing offset"
        );
    }

    /**
     * @notice Test the real contract detection logic simulation
     * @dev Shows how the vulnerable contract would actually behave
     */
    function test_SimulateVulnerableContractLogic() public view {
        console.log("\n=== SIMULATING VULNERABLE CONTRACT LOGIC ===");

        // This simulates what the vulnerable Arbitrum contract does
        function(address)
            internal
            view
            returns (bool) isContractVulnerable = _isContractVulnerable;

        console.log("Testing account detection with vulnerable logic...");

        // Test each account type
        bool eoaIsContract = isContractVulnerable(regularEOA);
        bool contractIsContract = isContractVulnerable(regularContract);
        bool eip7702IsContract = isContractVulnerable(eip7702Account);

        console.log("Regular EOA detected as contract:", eoaIsContract);
        console.log(
            "Regular Contract detected as contract:",
            contractIsContract
        );
        console.log(
            "EIP-7702 Account detected as contract:",
            eip7702IsContract
        );

        // Show the resulting L2 addresses
        address eoaL2 = eoaIsContract
            ? applyL1ToL2Alias(regularEOA)
            : regularEOA;
        address contractL2 = contractIsContract
            ? applyL1ToL2Alias(regularContract)
            : regularContract;
        address eip7702L2 = eip7702IsContract
            ? applyL1ToL2Alias(eip7702Account)
            : eip7702Account;

        console.log("\nResulting L2 addresses:");
        console.log("EOA L1->L2:", regularEOA, "->", eoaL2);
        console.log("Contract L1->L2:", regularContract, "->", contractL2);
        console.log("EIP-7702 L1->L2:", eip7702Account, "->", eip7702L2);

        // Verify the vulnerability
        assertFalse(eoaIsContract, "EOA should not be detected as contract");
        assertTrue(
            contractIsContract,
            "Contract should be detected as contract"
        );
        assertTrue(
            eip7702IsContract,
            "EIP-7702 incorrectly detected as contract (VULNERABILITY)"
        );

        assertEq(eoaL2, regularEOA, "EOA should not be aliased");
        assertNotEq(contractL2, regularContract, "Contract should be aliased");
        assertNotEq(
            eip7702L2,
            eip7702Account,
            "EIP-7702 incorrectly aliased (VULNERABILITY)"
        );
    }

    /**
     * @notice Simulates the vulnerable contract's isContract check
     * @dev This is what the vulnerable Arbitrum contract does - basic extcodesize check
     */
    function _isContractVulnerable(
        address account
    ) internal view returns (bool) {
        uint256 size;
        assembly {
            size := extcodesize(account)
        }
        return size > 0;
    }

    /**
     * @notice Apply L1 to L2 address aliasing (Arbitrum's formula)
     * @param l1Address The L1 address to alias
     * @return l2Address The aliased L2 address
     * @dev This is Arbitrum's address aliasing formula for contracts
     */
    function applyL1ToL2Alias(address l1Address) public pure returns (address) {
        uint160 offset = uint160(0x1111000000000000000000000000000000001111);
        unchecked {
            return address(uint160(l1Address) + offset);
        }
    }
}

/**
 * @notice Mock contract for testing regular contract behavior
 */
contract MockContract {
    uint256 public value;

    function setValue(uint256 _value) external {
        value = _value;
    }

    function getValue() external view returns (uint256) {
        return value;
    }
}

/**
 * @notice Mock delegate contract for EIP-7702 testing
 */
contract MockDelegateContract {
    uint256 public delegatedValue;

    function setDelegatedValue(uint256 _value) external {
        delegatedValue = _value;
    }

    function getDelegatedValue() external view returns (uint256) {
        return delegatedValue;
    }
}
